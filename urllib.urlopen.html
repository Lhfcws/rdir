
<head>
    <meta charset="UTF-8"/>
    <title>urllib.urlopen</title><style type="text/css">
    body {
        margin: 0;
        background: #EEEEEE;
    }
    body div#wrapper {
        margin-left: 5px;
        color: #333333;
        font-family: sans-serif;
    }
    body div#wrapper div.interval {
        width: 0;
        height: 31px;
        border-left: 1px solid #222222;
    }
    body div#wrapper div.tree_node div.node_info {
        font-size: 19px;
    }
    body div#wrapper div.tree_node div.node_info div.node_fullname {
        color: #992233;
        -moz-text-shadow: 0 0 1px #998833;
        -webkit-text-shadow: 0 0 1px #998833;
        text-shadow: 0 0 1px #998833;
    }
    body div#wrapper div.tree_node div.node_info div.node_type {
        color: #BB8899;
        -moz-text-shadow: 0 0 1px #DDDDDD;
        -webkit-text-shadow: 0 0 1px #DDDDDD;
        text-shadow: 0 0 1px #DDDDDD;
    }
    body div#wrapper div.tree_node div.node_doc {
        font-size: 18px;
        display: inline-block;
        margin-top: 5px;
        padding: 10px;
        padding-right: 50px;
        border: 1px solid #BBBBBB;
    }
    /*# sourceMappingURL=template.css.map */
    body div#header {
        width: 100%;
        margin-top: 40px;
        margin-bottom: 10px;
        padding: 10px;
        background-color: #BED4EB;
    }
    body div#header h1#header_text {
        font-size: 36px;
        margin: 0;
        text-shadow: #FFF 0px 1px 0px;
    }
    </style>
</head>
<body>
    <div id="header"><h1 id="header_text">urllib.urlopen</h1></div>
    <div id="wrapper"><div class="interval" style="margin-left: 0px">
</div>
<div class="tree_node" style="margin-left: 0px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_closure</div><div class="node_type">	Type&lt;NoneType&gt;</div></div>
     
</div>
<div class="interval" style="margin-left: 0px">
</div>
<div class="tree_node" style="margin-left: 0px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict</div><div class="node_type">	Type&lt;dict&gt;</div></div>
    <div class="node_doc">dict() -&gt; new empty dictionary<br/>dict(mapping) -&gt; new dictionary initialized from a mapping object's<br/>    (key, value) pairs<br/>dict(iterable) -&gt; new dictionary initialized as if via:<br/>    d = {}<br/>    for k, v in iterable:<br/>        d[k] = v<br/>dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs<br/>    in the keyword argument list.  For example:  dict(one=1, two=2)<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.viewitems</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.viewitems() -&gt; a set-like object providing a view on D's items<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.fromkeys</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.<br/>v defaults to None.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.setdefault</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.get</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.keys</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.keys() -&gt; list of D's keys<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.items</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.items() -&gt; list of D's (key, value) pairs, as 2-tuples<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.clear</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.clear() -&gt; None.  Remove all items from D.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.popitem</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a<br/>2-tuple; but raise KeyError if D is empty.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.update</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.<br/>If E present and has a .keys() method, does:     for k in E: D[k] = E[k]<br/>If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v<br/>In either case, this is followed by: for k in F: D[k] = F[k]<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.pop</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.<br/>If key is not found, d is returned if given, otherwise KeyError is raised<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.viewkeys</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.viewkeys() -&gt; a set-like object providing a view on D's keys<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.viewvalues</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.viewvalues() -&gt; an object providing a view on D's values<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.has_key</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.has_key(k) -&gt; True if D has a key k, else False<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.values</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.values() -&gt; list of D's values<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.itervalues</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.itervalues() -&gt; an iterator over the values of D<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.iteritems</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.iteritems() -&gt; an iterator over the (key, value) items of D<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.copy</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.copy() -&gt; a shallow copy of D<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_dict.iterkeys</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.iterkeys() -&gt; an iterator over the keys of D<br/></div></div>
<div class="interval" style="margin-left: 0px">
</div>
<div class="tree_node" style="margin-left: 0px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name</div><div class="node_type">	Type&lt;str&gt;</div></div>
    <div class="node_doc">str(object='') -&gt; string<br/><br/>Return a nice string representation of the object.<br/>If the argument is a string, the return value is the same object.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.upper</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.upper() -&gt; string<br/><br/>Return a copy of the string S converted to uppercase.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.lstrip</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.lstrip([chars]) -&gt; string or unicode<br/><br/>Return a copy of the string S with leading whitespace removed.<br/>If chars is given and not None, remove characters in chars instead.<br/>If chars is unicode, S will be converted to unicode before stripping<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.rpartition</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.rpartition(sep) -&gt; (head, sep, tail)<br/><br/>Search for the separator sep in S, starting at the end of S, and return<br/>the part before it, the separator itself, and the part after it.  If the<br/>separator is not found, return two empty strings and S.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.replace</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.replace(old, new[, count]) -&gt; string<br/><br/>Return a copy of string S with all occurrences of substring<br/>old replaced by new.  If the optional argument count is<br/>given, only the first count occurrences are replaced.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.endswith</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.endswith(suffix[, start[, end]]) -&gt; bool<br/><br/>Return True if S ends with the specified suffix, False otherwise.<br/>With optional start, test S beginning at that position.<br/>With optional end, stop comparing S at that position.<br/>suffix can also be a tuple of strings to try.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.splitlines</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.splitlines(keepends=False) -&gt; list of strings<br/><br/>Return a list of the lines in S, breaking at line boundaries.<br/>Line breaks are not included in the resulting list unless keepends<br/>is given and true.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.rfind</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.rfind(sub [,start [,end]]) -&gt; int<br/><br/>Return the highest index in S where substring sub is found,<br/>such that sub is contained within S[start:end].  Optional<br/>arguments start and end are interpreted as in slice notation.<br/><br/>Return -1 on failure.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.strip</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.strip([chars]) -&gt; string or unicode<br/><br/>Return a copy of the string S with leading and trailing<br/>whitespace removed.<br/>If chars is given and not None, remove characters in chars instead.<br/>If chars is unicode, S will be converted to unicode before stripping<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.isdigit</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.isdigit() -&gt; bool<br/><br/>Return True if all characters in S are digits<br/>and there is at least one character in S, False otherwise.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.ljust</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.ljust(width[, fillchar]) -&gt; string<br/><br/>Return S left-justified in a string of length width. Padding is<br/>done using the specified fill character (default is a space).<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.find</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.find(sub [,start [,end]]) -&gt; int<br/><br/>Return the lowest index in S where substring sub is found,<br/>such that sub is contained within S[start:end].  Optional<br/>arguments start and end are interpreted as in slice notation.<br/><br/>Return -1 on failure.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.index</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.index(sub [,start [,end]]) -&gt; int<br/><br/>Like S.find() but raise ValueError when the substring is not found.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.isalnum</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.isalnum() -&gt; bool<br/><br/>Return True if all characters in S are alphanumeric<br/>and there is at least one character in S, False otherwise.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.title</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.title() -&gt; string<br/><br/>Return a titlecased version of S, i.e. words start with uppercase<br/>characters, all remaining cased characters have lowercase.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.rindex</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.rindex(sub [,start [,end]]) -&gt; int<br/><br/>Like S.rfind() but raise ValueError when the substring is not found.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.rsplit</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.rsplit([sep [,maxsplit]]) -&gt; list of strings<br/><br/>Return a list of the words in the string S, using sep as the<br/>delimiter string, starting at the end of the string and working<br/>to the front.  If maxsplit is given, at most maxsplit splits are<br/>done. If sep is not specified or is None, any whitespace string<br/>is a separator.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.decode</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.decode([encoding[,errors]]) -&gt; object<br/><br/>Decodes S using the codec registered for encoding. encoding defaults<br/>to the default encoding. errors may be given to set a different error<br/>handling scheme. Default is 'strict' meaning that encoding errors raise<br/>a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'<br/>as well as any other name registered with codecs.register_error that is<br/>able to handle UnicodeDecodeErrors.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.isalpha</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.isalpha() -&gt; bool<br/><br/>Return True if all characters in S are alphabetic<br/>and there is at least one character in S, False otherwise.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.split</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.split([sep [,maxsplit]]) -&gt; list of strings<br/><br/>Return a list of the words in the string S, using sep as the<br/>delimiter string.  If maxsplit is given, at most maxsplit<br/>splits are done. If sep is not specified or is None, any<br/>whitespace string is a separator and empty strings are removed<br/>from the result.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.rstrip</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.rstrip([chars]) -&gt; string or unicode<br/><br/>Return a copy of the string S with trailing whitespace removed.<br/>If chars is given and not None, remove characters in chars instead.<br/>If chars is unicode, S will be converted to unicode before stripping<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.encode</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.encode([encoding[,errors]]) -&gt; object<br/><br/>Encodes S using the codec registered for encoding. encoding defaults<br/>to the default encoding. errors may be given to set a different error<br/>handling scheme. Default is 'strict' meaning that encoding errors raise<br/>a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and<br/>'xmlcharrefreplace' as well as any other name registered with<br/>codecs.register_error that is able to handle UnicodeEncodeErrors.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.translate</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.translate(table [,deletechars]) -&gt; string<br/><br/>Return a copy of the string S, where all characters occurring<br/>in the optional argument deletechars are removed, and the<br/>remaining characters have been mapped through the given<br/>translation table, which must be a string of length 256 or None.<br/>If the table argument is None, no translation is applied and<br/>the operation simply removes the characters in deletechars.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.isspace</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.isspace() -&gt; bool<br/><br/>Return True if all characters in S are whitespace<br/>and there is at least one character in S, False otherwise.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.startswith</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.startswith(prefix[, start[, end]]) -&gt; bool<br/><br/>Return True if S starts with the specified prefix, False otherwise.<br/>With optional start, test S beginning at that position.<br/>With optional end, stop comparing S at that position.<br/>prefix can also be a tuple of strings to try.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.format</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.format(*args, **kwargs) -&gt; string<br/><br/>Return a formatted version of S, using substitutions from args and kwargs.<br/>The substitutions are identified by braces ('{' and '}').<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.rjust</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.rjust(width[, fillchar]) -&gt; string<br/><br/>Return S right-justified in a string of length width. Padding is<br/>done using the specified fill character (default is a space)<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.swapcase</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.swapcase() -&gt; string<br/><br/>Return a copy of the string S with uppercase characters<br/>converted to lowercase and vice versa.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.zfill</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.zfill(width) -&gt; string<br/><br/>Pad a numeric string S with zeros on the left, to fill a field<br/>of the specified width.  The string S is never truncated.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.capitalize</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.capitalize() -&gt; string<br/><br/>Return a copy of the string S with only its first character<br/>capitalized.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.count</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.count(sub[, start[, end]]) -&gt; int<br/><br/>Return the number of non-overlapping occurrences of substring sub in<br/>string S[start:end].  Optional arguments start and end are interpreted<br/>as in slice notation.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.lower</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.lower() -&gt; string<br/><br/>Return a copy of the string S converted to lowercase.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.join</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.join(iterable) -&gt; string<br/><br/>Return a string which is the concatenation of the strings in the<br/>iterable.  The separator between elements is S.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.center</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.center(width[, fillchar]) -&gt; string<br/><br/>Return S centered in a string of length width. Padding is<br/>done using the specified fill character (default is a space)<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.partition</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.partition(sep) -&gt; (head, sep, tail)<br/><br/>Search for the separator sep in S, and return the part before it,<br/>the separator itself, and the part after it.  If the separator is not<br/>found, return S and two empty strings.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.expandtabs</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.expandtabs([tabsize]) -&gt; string<br/><br/>Return a copy of S where all tab characters are expanded using spaces.<br/>If tabsize is not given, a tab size of 8 characters is assumed.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.istitle</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.istitle() -&gt; bool<br/><br/>Return True if S is a titlecased string and there is at least one<br/>character in S, i.e. uppercase characters may only follow uncased<br/>characters and lowercase characters only cased ones. Return False<br/>otherwise.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.islower</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.islower() -&gt; bool<br/><br/>Return True if all cased characters in S are lowercase and there is<br/>at least one cased character in S, False otherwise.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_name.isupper</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.isupper() -&gt; bool<br/><br/>Return True if all cased characters in S are uppercase and there is<br/>at least one cased character in S, False otherwise.<br/></div></div>
<div class="interval" style="margin-left: 0px">
</div>
<div class="tree_node" style="margin-left: 0px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_defaults</div><div class="node_type">	Type&lt;tuple&gt;</div></div>
    <div class="node_doc">tuple() -&gt; empty tuple<br/>tuple(iterable) -&gt; tuple initialized from iterable's items<br/><br/>If the argument is a tuple, the return value is the same object.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_defaults.count</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">T.count(value) -&gt; integer -- return number of occurrences of value<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_defaults.index</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.<br/>Raises ValueError if the value is not present.<br/></div></div>
<div class="interval" style="margin-left: 0px">
</div>
<div class="tree_node" style="margin-left: 0px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code</div><div class="node_type">	Type&lt;code&gt;</div></div>
    <div class="node_doc">code(argcount, nlocals, stacksize, flags, codestring, constants, names,<br/>      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])<br/><br/>Create a code object.  Not for the faint of heart.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_firstlineno</div><div class="node_type">	Type&lt;int&gt;</div></div>
    <div class="node_doc">int(x=0) -&gt; int or long<br/>int(x, base=10) -&gt; int or long<br/><br/>Convert a number or string to an integer, or return 0 if no arguments<br/>are given.  If x is floating point, the conversion truncates towards zero.<br/>If x is outside the integer range, the function returns a long instead.<br/><br/>If x is not a number or if base is given, then x must be a string or<br/>Unicode object representing an integer literal in the given base.  The<br/>literal can be preceded by '+' or '-' and be surrounded by whitespace.<br/>The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to<br/>interpret the base from the string as an integer literal.<br/>&gt;&gt;&gt; int('0b100', base=0)<br/>4<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_code</div><div class="node_type">	Type&lt;str&gt;</div></div>
    <div class="node_doc">str(object='') -&gt; string<br/><br/>Return a nice string representation of the object.<br/>If the argument is a string, the return value is the same object.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_freevars</div><div class="node_type">	Type&lt;tuple&gt;</div></div>
    <div class="node_doc">tuple() -&gt; empty tuple<br/>tuple(iterable) -&gt; tuple initialized from iterable's items<br/><br/>If the argument is a tuple, the return value is the same object.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_consts</div><div class="node_type">	Type&lt;tuple&gt;</div></div>
    <div class="node_doc">tuple() -&gt; empty tuple<br/>tuple(iterable) -&gt; tuple initialized from iterable's items<br/><br/>If the argument is a tuple, the return value is the same object.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_name</div><div class="node_type">	Type&lt;str&gt;</div></div>
    <div class="node_doc">str(object='') -&gt; string<br/><br/>Return a nice string representation of the object.<br/>If the argument is a string, the return value is the same object.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_filename</div><div class="node_type">	Type&lt;str&gt;</div></div>
    <div class="node_doc">str(object='') -&gt; string<br/><br/>Return a nice string representation of the object.<br/>If the argument is a string, the return value is the same object.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_lnotab</div><div class="node_type">	Type&lt;str&gt;</div></div>
    <div class="node_doc">str(object='') -&gt; string<br/><br/>Return a nice string representation of the object.<br/>If the argument is a string, the return value is the same object.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_flags</div><div class="node_type">	Type&lt;int&gt;</div></div>
    <div class="node_doc">int(x=0) -&gt; int or long<br/>int(x, base=10) -&gt; int or long<br/><br/>Convert a number or string to an integer, or return 0 if no arguments<br/>are given.  If x is floating point, the conversion truncates towards zero.<br/>If x is outside the integer range, the function returns a long instead.<br/><br/>If x is not a number or if base is given, then x must be a string or<br/>Unicode object representing an integer literal in the given base.  The<br/>literal can be preceded by '+' or '-' and be surrounded by whitespace.<br/>The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to<br/>interpret the base from the string as an integer literal.<br/>&gt;&gt;&gt; int('0b100', base=0)<br/>4<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_nlocals</div><div class="node_type">	Type&lt;int&gt;</div></div>
    <div class="node_doc">int(x=0) -&gt; int or long<br/>int(x, base=10) -&gt; int or long<br/><br/>Convert a number or string to an integer, or return 0 if no arguments<br/>are given.  If x is floating point, the conversion truncates towards zero.<br/>If x is outside the integer range, the function returns a long instead.<br/><br/>If x is not a number or if base is given, then x must be a string or<br/>Unicode object representing an integer literal in the given base.  The<br/>literal can be preceded by '+' or '-' and be surrounded by whitespace.<br/>The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to<br/>interpret the base from the string as an integer literal.<br/>&gt;&gt;&gt; int('0b100', base=0)<br/>4<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_stacksize</div><div class="node_type">	Type&lt;int&gt;</div></div>
    <div class="node_doc">int(x=0) -&gt; int or long<br/>int(x, base=10) -&gt; int or long<br/><br/>Convert a number or string to an integer, or return 0 if no arguments<br/>are given.  If x is floating point, the conversion truncates towards zero.<br/>If x is outside the integer range, the function returns a long instead.<br/><br/>If x is not a number or if base is given, then x must be a string or<br/>Unicode object representing an integer literal in the given base.  The<br/>literal can be preceded by '+' or '-' and be surrounded by whitespace.<br/>The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to<br/>interpret the base from the string as an integer literal.<br/>&gt;&gt;&gt; int('0b100', base=0)<br/>4<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_argcount</div><div class="node_type">	Type&lt;int&gt;</div></div>
    <div class="node_doc">int(x=0) -&gt; int or long<br/>int(x, base=10) -&gt; int or long<br/><br/>Convert a number or string to an integer, or return 0 if no arguments<br/>are given.  If x is floating point, the conversion truncates towards zero.<br/>If x is outside the integer range, the function returns a long instead.<br/><br/>If x is not a number or if base is given, then x must be a string or<br/>Unicode object representing an integer literal in the given base.  The<br/>literal can be preceded by '+' or '-' and be surrounded by whitespace.<br/>The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to<br/>interpret the base from the string as an integer literal.<br/>&gt;&gt;&gt; int('0b100', base=0)<br/>4<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_cellvars</div><div class="node_type">	Type&lt;tuple&gt;</div></div>
    <div class="node_doc">tuple() -&gt; empty tuple<br/>tuple(iterable) -&gt; tuple initialized from iterable's items<br/><br/>If the argument is a tuple, the return value is the same object.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_varnames</div><div class="node_type">	Type&lt;tuple&gt;</div></div>
    <div class="node_doc">tuple() -&gt; empty tuple<br/>tuple(iterable) -&gt; tuple initialized from iterable's items<br/><br/>If the argument is a tuple, the return value is the same object.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_code.co_names</div><div class="node_type">	Type&lt;tuple&gt;</div></div>
    <div class="node_doc">tuple() -&gt; empty tuple<br/>tuple(iterable) -&gt; tuple initialized from iterable's items<br/><br/>If the argument is a tuple, the return value is the same object.<br/></div></div>
<div class="interval" style="margin-left: 0px">
</div>
<div class="tree_node" style="margin-left: 0px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc</div><div class="node_type">	Type&lt;str&gt;</div></div>
    <div class="node_doc">str(object='') -&gt; string<br/><br/>Return a nice string representation of the object.<br/>If the argument is a string, the return value is the same object.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.upper</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.upper() -&gt; string<br/><br/>Return a copy of the string S converted to uppercase.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.lstrip</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.lstrip([chars]) -&gt; string or unicode<br/><br/>Return a copy of the string S with leading whitespace removed.<br/>If chars is given and not None, remove characters in chars instead.<br/>If chars is unicode, S will be converted to unicode before stripping<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.rpartition</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.rpartition(sep) -&gt; (head, sep, tail)<br/><br/>Search for the separator sep in S, starting at the end of S, and return<br/>the part before it, the separator itself, and the part after it.  If the<br/>separator is not found, return two empty strings and S.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.replace</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.replace(old, new[, count]) -&gt; string<br/><br/>Return a copy of string S with all occurrences of substring<br/>old replaced by new.  If the optional argument count is<br/>given, only the first count occurrences are replaced.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.endswith</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.endswith(suffix[, start[, end]]) -&gt; bool<br/><br/>Return True if S ends with the specified suffix, False otherwise.<br/>With optional start, test S beginning at that position.<br/>With optional end, stop comparing S at that position.<br/>suffix can also be a tuple of strings to try.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.splitlines</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.splitlines(keepends=False) -&gt; list of strings<br/><br/>Return a list of the lines in S, breaking at line boundaries.<br/>Line breaks are not included in the resulting list unless keepends<br/>is given and true.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.rfind</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.rfind(sub [,start [,end]]) -&gt; int<br/><br/>Return the highest index in S where substring sub is found,<br/>such that sub is contained within S[start:end].  Optional<br/>arguments start and end are interpreted as in slice notation.<br/><br/>Return -1 on failure.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.strip</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.strip([chars]) -&gt; string or unicode<br/><br/>Return a copy of the string S with leading and trailing<br/>whitespace removed.<br/>If chars is given and not None, remove characters in chars instead.<br/>If chars is unicode, S will be converted to unicode before stripping<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.isdigit</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.isdigit() -&gt; bool<br/><br/>Return True if all characters in S are digits<br/>and there is at least one character in S, False otherwise.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.ljust</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.ljust(width[, fillchar]) -&gt; string<br/><br/>Return S left-justified in a string of length width. Padding is<br/>done using the specified fill character (default is a space).<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.find</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.find(sub [,start [,end]]) -&gt; int<br/><br/>Return the lowest index in S where substring sub is found,<br/>such that sub is contained within S[start:end].  Optional<br/>arguments start and end are interpreted as in slice notation.<br/><br/>Return -1 on failure.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.index</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.index(sub [,start [,end]]) -&gt; int<br/><br/>Like S.find() but raise ValueError when the substring is not found.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.isalnum</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.isalnum() -&gt; bool<br/><br/>Return True if all characters in S are alphanumeric<br/>and there is at least one character in S, False otherwise.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.title</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.title() -&gt; string<br/><br/>Return a titlecased version of S, i.e. words start with uppercase<br/>characters, all remaining cased characters have lowercase.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.rindex</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.rindex(sub [,start [,end]]) -&gt; int<br/><br/>Like S.rfind() but raise ValueError when the substring is not found.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.rsplit</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.rsplit([sep [,maxsplit]]) -&gt; list of strings<br/><br/>Return a list of the words in the string S, using sep as the<br/>delimiter string, starting at the end of the string and working<br/>to the front.  If maxsplit is given, at most maxsplit splits are<br/>done. If sep is not specified or is None, any whitespace string<br/>is a separator.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.decode</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.decode([encoding[,errors]]) -&gt; object<br/><br/>Decodes S using the codec registered for encoding. encoding defaults<br/>to the default encoding. errors may be given to set a different error<br/>handling scheme. Default is 'strict' meaning that encoding errors raise<br/>a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'<br/>as well as any other name registered with codecs.register_error that is<br/>able to handle UnicodeDecodeErrors.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.isalpha</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.isalpha() -&gt; bool<br/><br/>Return True if all characters in S are alphabetic<br/>and there is at least one character in S, False otherwise.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.split</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.split([sep [,maxsplit]]) -&gt; list of strings<br/><br/>Return a list of the words in the string S, using sep as the<br/>delimiter string.  If maxsplit is given, at most maxsplit<br/>splits are done. If sep is not specified or is None, any<br/>whitespace string is a separator and empty strings are removed<br/>from the result.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.rstrip</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.rstrip([chars]) -&gt; string or unicode<br/><br/>Return a copy of the string S with trailing whitespace removed.<br/>If chars is given and not None, remove characters in chars instead.<br/>If chars is unicode, S will be converted to unicode before stripping<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.encode</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.encode([encoding[,errors]]) -&gt; object<br/><br/>Encodes S using the codec registered for encoding. encoding defaults<br/>to the default encoding. errors may be given to set a different error<br/>handling scheme. Default is 'strict' meaning that encoding errors raise<br/>a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and<br/>'xmlcharrefreplace' as well as any other name registered with<br/>codecs.register_error that is able to handle UnicodeEncodeErrors.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.translate</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.translate(table [,deletechars]) -&gt; string<br/><br/>Return a copy of the string S, where all characters occurring<br/>in the optional argument deletechars are removed, and the<br/>remaining characters have been mapped through the given<br/>translation table, which must be a string of length 256 or None.<br/>If the table argument is None, no translation is applied and<br/>the operation simply removes the characters in deletechars.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.isspace</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.isspace() -&gt; bool<br/><br/>Return True if all characters in S are whitespace<br/>and there is at least one character in S, False otherwise.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.startswith</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.startswith(prefix[, start[, end]]) -&gt; bool<br/><br/>Return True if S starts with the specified prefix, False otherwise.<br/>With optional start, test S beginning at that position.<br/>With optional end, stop comparing S at that position.<br/>prefix can also be a tuple of strings to try.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.format</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.format(*args, **kwargs) -&gt; string<br/><br/>Return a formatted version of S, using substitutions from args and kwargs.<br/>The substitutions are identified by braces ('{' and '}').<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.rjust</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.rjust(width[, fillchar]) -&gt; string<br/><br/>Return S right-justified in a string of length width. Padding is<br/>done using the specified fill character (default is a space)<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.swapcase</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.swapcase() -&gt; string<br/><br/>Return a copy of the string S with uppercase characters<br/>converted to lowercase and vice versa.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.zfill</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.zfill(width) -&gt; string<br/><br/>Pad a numeric string S with zeros on the left, to fill a field<br/>of the specified width.  The string S is never truncated.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.capitalize</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.capitalize() -&gt; string<br/><br/>Return a copy of the string S with only its first character<br/>capitalized.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.count</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.count(sub[, start[, end]]) -&gt; int<br/><br/>Return the number of non-overlapping occurrences of substring sub in<br/>string S[start:end].  Optional arguments start and end are interpreted<br/>as in slice notation.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.lower</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.lower() -&gt; string<br/><br/>Return a copy of the string S converted to lowercase.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.join</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.join(iterable) -&gt; string<br/><br/>Return a string which is the concatenation of the strings in the<br/>iterable.  The separator between elements is S.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.center</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.center(width[, fillchar]) -&gt; string<br/><br/>Return S centered in a string of length width. Padding is<br/>done using the specified fill character (default is a space)<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.partition</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.partition(sep) -&gt; (head, sep, tail)<br/><br/>Search for the separator sep in S, and return the part before it,<br/>the separator itself, and the part after it.  If the separator is not<br/>found, return S and two empty strings.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.expandtabs</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.expandtabs([tabsize]) -&gt; string<br/><br/>Return a copy of S where all tab characters are expanded using spaces.<br/>If tabsize is not given, a tab size of 8 characters is assumed.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.istitle</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.istitle() -&gt; bool<br/><br/>Return True if S is a titlecased string and there is at least one<br/>character in S, i.e. uppercase characters may only follow uncased<br/>characters and lowercase characters only cased ones. Return False<br/>otherwise.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.islower</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.islower() -&gt; bool<br/><br/>Return True if all cased characters in S are lowercase and there is<br/>at least one cased character in S, False otherwise.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_doc.isupper</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">S.isupper() -&gt; bool<br/><br/>Return True if all cased characters in S are uppercase and there is<br/>at least one cased character in S, False otherwise.<br/></div></div>
<div class="interval" style="margin-left: 0px">
</div>
<div class="tree_node" style="margin-left: 0px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals</div><div class="node_type">	Type&lt;dict&gt;</div></div>
    <div class="node_doc">dict() -&gt; new empty dictionary<br/>dict(mapping) -&gt; new dictionary initialized from a mapping object's<br/>    (key, value) pairs<br/>dict(iterable) -&gt; new dictionary initialized as if via:<br/>    d = {}<br/>    for k, v in iterable:<br/>        d[k] = v<br/>dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs<br/>    in the keyword argument list.  For example:  dict(one=1, two=2)<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.viewitems</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.viewitems() -&gt; a set-like object providing a view on D's items<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.fromkeys</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.<br/>v defaults to None.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.setdefault</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.get</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.keys</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.keys() -&gt; list of D's keys<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.items</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.items() -&gt; list of D's (key, value) pairs, as 2-tuples<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.clear</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.clear() -&gt; None.  Remove all items from D.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.popitem</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a<br/>2-tuple; but raise KeyError if D is empty.<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.update</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.<br/>If E present and has a .keys() method, does:     for k in E: D[k] = E[k]<br/>If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v<br/>In either case, this is followed by: for k in F: D[k] = F[k]<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.pop</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.<br/>If key is not found, d is returned if given, otherwise KeyError is raised<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.viewkeys</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.viewkeys() -&gt; a set-like object providing a view on D's keys<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.viewvalues</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.viewvalues() -&gt; an object providing a view on D's values<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.has_key</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.has_key(k) -&gt; True if D has a key k, else False<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.values</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.values() -&gt; list of D's values<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.itervalues</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.itervalues() -&gt; an iterator over the values of D<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.iteritems</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.iteritems() -&gt; an iterator over the (key, value) items of D<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.copy</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.copy() -&gt; a shallow copy of D<br/></div></div>
<div class="interval" style="margin-left: 50px">
</div>
<div class="tree_node" style="margin-left: 50px">
    <div class="node_info">
        <div class="node_fullname">urllib.urlopen.func_globals.iterkeys</div><div class="node_type">	Type&lt;builtin_function_or_method&gt;</div></div>
    <div class="node_doc">D.iterkeys() -&gt; an iterator over the keys of D<br/></div></div>
</div>
</body>
